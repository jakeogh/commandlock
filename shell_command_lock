#!/bin/sh

# shell_command_lock - Atomic locking for shell commands.
# https://github.com/jakeogh/shell_command_lock

readonly lock_folder_scl="/dev/shm"	# using tempfs to delete orphaned
					# locks on reboot

if [ ! -d "${lock_folder_scl}" ]; then
	echo "ERROR: [$$] $0 $* ${lock_folder_scl} not a directory." >&2
	exit 1
fi

readonly lock_name_scl=$(set -o pipefail ; \
	echo "$0 $*" | sha1sum | cut -d ' ' -f 1) \
	|| { echo "ERROR: [$$] $0 $* generating lock_name." >&2 ; exit 1 ; }

if [ "${#lock_name_scl}" != "40" ]; then
	echo "ERROR: [$$] $0 $* lock_name \"${lock_name_scl}"\"
	echo "is not (sha1) 40 bytes long." >&2
	exit 1
fi

readonly lock_scl="${lock_folder_scl}/lock_${lock_name_scl}"

if ( set -o noclobber; : > "${lock_scl}" ) 2> /dev/null; then # got lock
	# setting trap after creating lock
	# this must be done after, otherwise locked-out scripts will delete
	# the lock becuase they set the trap before they attempt to acquire
	# the lock.
	trap 'unlink -- "${lock_scl}"' \
		INT HUP ALRM PIPE PROF USR1 USR2 VTALRM STKFLT QUIT ABRT TERM EXIT

#	echo "Locking succeeded: ${lock_scl}" >&2
	echo "$$" >> "${lock_scl}"
else
	echo "ERROR: [$$] $0 $* Locking failed: ${lock_scl}" >&2
	/bin/ls -al "${lock_scl}"
	echo "ERROR: [$$] $0 $* is/was already running. Exiting (1)." >&2
	exit 1
fi
