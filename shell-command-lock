#!/bin/sh

# shell_command_lock - Atomic locking for commands.
# https://github.com/jakeogh/shell-command-lock

# use tempfs to delete orphaned locks on reboot
readonly lock_folder_scl="/dev/shm"

if [ ! -d "${lock_folder_scl}" ]; then
    echo "ERROR: [$$] $0 $* ${lock_folder_scl} not a directory." >&2
    exit 1
fi

readonly lock_name_scl=$(set -o pipefail ; \
    echo "$0 $*" | sha1sum | cut -d ' ' -f 1) \
    || { echo "ERROR: [$$] $0 $* generating lock_name." >&2 ; exit 1 ; }

if [ "${#lock_name_scl}" != "40" ]; then
    echo "ERROR: [$$] $0 $* lock_name \"${lock_name_scl}"\"
    echo "is not (sha1) 40 bytes long." >&2
    exit 1
fi

readonly lock_scl="${lock_folder_scl}/lock_${lock_name_scl}"

if ( set -o noclobber; : > "${lock_scl}" ) 2> /dev/null; then # got lock
    # the trap must be set after creating lock, otherwise locked-out scripts
    # will delete the lock becuase they set the trap before they attempt to
    # acquire the lock.
    trap 'unlink -- "${lock_scl}"' \
        INT HUP ALRM PIPE PROF USR1 USR2 VTALRM STKFLT QUIT ABRT TERM EXIT

#   echo "Locking succeeded: ${lock_scl}" >&2
    echo "$$" >> "${lock_scl}"
else
    echo "ERROR: [$$] $0 $* Locking failed: ${lock_scl}" >&2
    echo "ERROR: [$$] $0 $* is/was already running. Exiting (1)." >&2
    exit 1
fi
